#ifndef __ACP__INTEGER_OVERFLOW_CHECK_AH__
#define __ACP__INTEGER_OVERFLOW_CHECK_AH__

#include "../core/core_aspect.ah"
#include "overflow_exception.hh"

#include <limits>

namespace acp {
    /**
     * \attribute acp::overflow_check
     * \brief Triggers an integer over- /underflow check for all integer addition and subtraction
     *
     * This attribute marks a join point, on which the IntegerOverflowCheck aspect should be applied.
     */
    attribute overflow_check();

    /**
     * \attribute acp::ignore_overflow_check
     * \brief This attribute can be used to exclude certain join points form being affected by this aspect.
     *
     * If a scope already is annotated with this aspect's attribute, individual join points within can be
     * excluded with this attribute.
     */
    attribute ignore_overflow_check();
}

/**
 * \aspect IntegerOverflowCheck
 * \file /src/bug_detection/integer_overflow_check.ah
 * \brief Aspect that checks for null pointer dereferences.
 *
 * This aspect is used to detect an over- od underflow within one of the 10 standard (5 binary and all
 * 5 unary) integer addition and subtraction operators. In the case that such an over- or underflow will
 * occur an exception will be triggered and the operation will not be performed.
 *
 * \see acp::OverflowException
 */
aspect [[acp::middle_layer]] IntegerOverflowCheck : public CoreAspect {

    // This design is very expandable. simple copy the current version used for integers and expand
    // it with other types like short, long or char.

    static constexpr int max = std::numeric_limits<int>::max();
    static constexpr int min = std::numeric_limits<int>::min();

    /**
     * \pointcut int_add_binary
     * \brief The set of all builtin binary integer addition join points.
     */
    pointcut int_add_binary() = builtin("int& operator +=(int&,int)" || "int operator +(int,int)");

    /**
     * \pointcut int_add_unary_inc
     * \brief The set of all builtin integer increment join points.
     */
    pointcut int_add_unary_inc() = builtin("int operator ++(int&,int)" || "int& operator ++(int&)");

    /**
     * \pointcut int_add_unary
     * \brief The set of all builtin unary integer addition join points.
     */
    pointcut int_add_unary() = builtin("int operator +(int)");

    /**
     * \pointcut int_sub_binary
     * \brief The set of all builtin binary integer subtraction join points.
     */
    pointcut int_sub_binary() = builtin("int& operator -=(int&,int)" || "int operator -(int,int)");

    /**
     * \pointcut int_sub_unary_inc
     * \brief The set of all builtin integer decrement join points.
     */
    pointcut int_sub_unary_inc() = builtin("int operator --(int&,int)" || "int& operator --(int&)");

    /**
     * \pointcut int_sub_unary
     * \brief The set of all builtin unary integer subtraction join points.
     */
    pointcut int_sub_unary() = builtin("int operator -(int)");

public:

    IntegerOverflowCheck() {}
    virtual ~IntegerOverflowCheck() = default;

    /**
     * \pointcut where
     * \see :ref:`CoreAspect::where <core_aspect_ah_where>`
     */
    pointcut virtual where() = within(acp::overflow_check());

    /**
     * \pointcut ignore
     * \see :ref:`CoreAspect::ignore <core_aspect_ah_ignore>`
     */
    pointcut virtual ignore() = within("OverflowCheck") || within("acp") || within(acp::ignore_overflow_check()) || within(acp::ignore_everything());


    /**
     * \advice int_add_binary_check
     * \brief This advice checks for an overflow in the 'int += int' and 'int + int' operator.
     */
    advice where() && int_add_binary() && !ignore(): before() {
        const int lhs = *static_cast<int*>(tjp->arg(0));
        const int rhs = *static_cast<int*>(tjp->arg(1));
        if(lhs > max - rhs) {
            throw acp::OverflowException(tjp->signature(), tjp->line(), "int", true);
        }
    }

    /**
     * \advice int_add_unary_inc_check
     * \brief This advice checks for an overflow in the '++int' and 'int++' operator.
     */
    advice where() && int_add_unary_inc() && !ignore(): before() {
        const int val = *static_cast<int*>(tjp->arg(0));
        if(val == max) {
            throw acp::OverflowException(tjp->signature(), tjp->line(), "int", true);
        }
    }

    /**
     * \advice int_add_unary_check
     * \brief This advice checks for an overflow in the '+int' operator.
     */
    advice where() && int_add_unary() && !ignore(): before() {
        const int val = *static_cast<int*>(tjp->arg(0));
        if(val == min) {
            throw acp::OverflowException(tjp->signature(), tjp->line(), "int", true);
        }
    }

    /**
     * \advice int_sub_binary_check
     * \brief This advice checks for an underflow in the 'int -= int' and 'int - int' operator.
     */
    advice where() && int_sub_binary() && !ignore(): before() {
        const int lhs = *static_cast<int*>(tjp->arg(0));
        const int rhs = *static_cast<int*>(tjp->arg(1));
        if(lhs < max + rhs) {
            throw acp::OverflowException(tjp->signature(), tjp->line(), "int", false);
        }
    }

    /**
     * \advice int_sub_unary_inc_check
     * \brief This advice checks for an underflow in the '--int' and 'int--' operator.
     */
    advice where() && int_sub_unary_inc() && !ignore(): before() {
        const int val = *static_cast<int*>(tjp->arg(0));
        if(val == min) {
            throw acp::OverflowException(tjp->signature(), tjp->line(), "int", false);
        }
    }

    /**
     * \advice int_sub_unary_check
     * \brief This advice checks for an underflow in the '--int' operator (spoiler: it cant happen :D).
     */
    advice where() && int_sub_unary() && !ignore(): before() {
        // Every positive number can be inverted to a negative, but not the over way around.
    }

};

#endif // __ACP__INTEGER_OVERFLOW_CHECK_AH__
