#ifndef __ACP__PROFILER_AH__
#define __ACP__PROFILER_AH__

#include "../core/core_aspect.ah"
#include "../core/predefined_pointcuts.ah"
#include "../core/printer.hh"
#include "../core/thread_controller.hh"
#include "../core/custom_to_string.hh"
#include "profiler_data.hh"

namespace acp {
	/**
	 * \attribute acp::profile
	 * \brief This attribute is used to mark join points that should be profiled.
	 */
	attribute profile();

	/**
	 * \attribute acp::ignore_profile()
     * \brief This attribute can be used to exclude certain join points form being affected by this aspect.
     *
     * If a scope already is annotated with this aspect's attribute, individual join points within can be
     * excluded with this attribute.
     */
	attribute ignore_profile();
}

/**
 * \aspect Profiler
 * \file src/understanding/profiler.ah
 * \brief This aspect is used to profile the execution time and call amount of functions and methods.
 *
 * Creates a grouped list by signature name of all profiled functions and methods. The list is printed
 * after the execution of the main function.
 * The list entries themself are shaped by the "build_msg()" function. You can replace its content
 * easily by writing an aspect to replace it.
 * The preferred printing device, which is provided to the constructor, is used to make an output.
 */
aspect [[acp::inner_layer]] Profiler : public CoreAspect{

	acp::Printer* _printer;

	// Useing this wrapper function to create static header only variable in c++11
	inline static acp::Printer* static_printer_instance(acp::Printer* instance = nullptr) {
		static acp::Printer* _static_printer = nullptr;
		if (instance) {
			_static_printer = instance;
		}
		return _static_printer;
	}

protected:

	/**
	 * \function build_msg
     * \brief This function is responsible for creating a well formatted profiler message.
     *
     * In case you want to change this, write an aspect which replaces this function with your
	 * own implementation. Use a around advice for that.
     *
	 * \param data the profiling data to be used for building the message.
	 * \param output reference to a string which will contain the output in the end.
	 */
	inline static void build_msg(const acp::ProfilerData& data, std::string& output){
		char buffer1[12], buffer2[12];
        acp::to_string(buffer1, data.m_calls, sizeof(buffer1));
        acp::to_string(buffer2, data.m_exec_time.count(), sizeof(buffer2));
        output.clear();
        output.append(data.m_signature);
        output.append(": called ");
        output.append(buffer1);
        output.append(" times within ");
        output.append(buffer2);
        output.append(" nanoseconds.\n");
	}

public:
	/**
	 * \pointcut ignore
	 * \see :ref:`CoreAspect::ignore <core_aspect_ah_ignore>`
	 */
    pointcut virtual ignore() = within("Profiler") || within("acp") || execution(acp::ignore_profile()) || execution(acp::ignore_everything());

	/**
	 * \pointcut where
	 * \see :ref:`CoreAspect::where <core_aspect_ah_where>`
	 */
    pointcut virtual where() = execution(acp::profile());


    Profiler(): Profiler(nullptr) {}

	/**
	 * \constructor Constructor
	 * \brief This constructor initializes the profiler with a builder, printer and thread controller.
	 */
    Profiler(acp::Printer* printer): _printer(printer) {
		Profiler::static_printer_instance(printer);
	}

	virtual ~Profiler() {
		delete _printer;
	}

	/**
	 * \advice profile-advice
	 * \brief This advice collects relevant data and stores it for later use.
	 *
	 * It measures the execution time and call count of the function or method.
	 * It uses a static instance of acp::ProfilerData to store the profiling data.
	 * The profiling data is updated in a thread-safe manner using the ThreadController.
	 *
	 * \see acp::ProfilerData
	 */
    advice where() && !ignore(): around() {
		acp::thread_controller::acquire_global_lock();
    	static acp::ProfilerData data (JoinPoint::signature());
		acp::thread_controller::release_global_lock();
		const auto start = std::chrono::high_resolution_clock::now();
		tjp->proceed();
		const auto end = std::chrono::high_resolution_clock::now();
		acp::thread_controller::acquire_global_lock();
		data.m_calls++;
		data.m_exec_time += end - start;
		acp::thread_controller::release_global_lock();
    }

	/**
	 * \function simple_stat
	 * \brief This function prints the profiling data of all profiled functions and methods.
	 */
    static void simple_stat () {
		for (acp::ProfilerData *curr = acp::ProfilerData::first (); curr; curr = curr->p_next) {
			std::string output;
			build_msg(*curr, output);
			Profiler::static_printer_instance()->print(output);
		}
      }

	  /**
	   * \function summary
	   * \brief This function returns a pointer to the simple_stat function.
	   *
	   * This function is virtual and can therefore be overridden by derived classes.
	   * It is used to provide the register-advice with a function pointer to be called at exit.
	   * \return (In this case) A pointer to the simple_stat function, which prints the profiling data.
	   */
    virtual void (*summary())() {
        return &simple_stat;
      }

	/**
	 * \advice register-advice
	 * \brief This advice registers the summary function to at_exit to delay the printing as much as possible.
	 *
	 * Atexit will receive the result of the function. it expects a function pointer to
	 * a function that returns void and takes no arguments and is not class bound. Using the atexit()
	 * function, the most amount of information can be gathered about the program before it exits.
	 */
    advice execution(acp::main_function()) : after () {
        atexit (summary());
    }

};

#endif // __ACP__PROFILER_AH__
