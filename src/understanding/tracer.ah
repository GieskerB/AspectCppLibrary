#ifndef __ACP__TRACER_AH__
#define __ACP__TRACER_AH__

#include "../core/core_aspect.ah"
#include "../core/predefined_pointcuts.ah"
#include "../core/printer.hh"
#include "../core/thread_controller.hh"
#include "../core/custom_to_string.hh"
#include "tracer_data.hh"

namespace acp {
	/**
	 * \attribute acp::trace
	 * \brief This attribute is used to mark join points that should be traced.
	 */
	attribute trace();

	/**
	 * \attribute acp::ignore_trace
     * \brief This attribute can be used to exclude certain join points form being affected by this aspect.
     *
     * If a scope already is annotated with this aspect's attribute, individual join points within can be
     * excluded with this attribute.
     */
	attribute ignore_trace();
}

/**
 * \aspect Tracer
 * \file src/understanding/tracer.ah
 * \brief This aspect is used to trace the execution time and call amount of functions and methods.
 *
 * Creates a ordered list of all traced functions and methods. The list is printed after the
 * execution of the main function.
 * The list entries themself are shaped by the "build_msg()" function. You can replace its content
 * easily by writing an aspect to replace it.
 * The preferred printing device, which is provided to the constructor, is used to make an output.
 */
aspect [[acp::inner_layer]]  Tracer : public CoreAspect {

	acp::Printer* _printer;

	// Useing this wrapper function to create static header only variable in c++11
	inline static acp::Printer* static_printer_instance(acp::Printer* instance = nullptr) {
		static acp::Printer* _static_printer = nullptr;
		if (instance) {
			_static_printer = instance;
		}
		return _static_printer;
	}
protected:

    /**
	 * \function build_msg
     * \brief This function is responsible for creating a well formatted tracer message.
     *
     * In case you want to change this, write an aspect which replaces this function with your
	 * own implementation. Use a around advice for that.
     *
	 * \param data the tracing data to be used for building the message.
	 * \param output reference to a string which will contain the output in the end.
	 */
	inline static void build_msg(const acp::TracerData& data, std::string& output){
		char buffer[12];
        acp::to_string(buffer, data.m_timestamp.count(), sizeof(buffer));
        output.clear();
        output.append(data.m_signature);
        output.append(": traced at ");
        output.append(buffer);
        output.append(" nanoseconds.\n");
	}

public:

    /**
	 * \pointcut ignore
	 * \see :ref:`CoreAspect::ignore <core_aspect_ah_ignore>`
	 */
    pointcut virtual ignore() = within("Tracer") || within("acp") || execution(acp::ignore_trace()) || execution(acp::ignore_everything());

	/**
	 * \pointcut where
	 * \see :ref:`CoreAspect::where <core_aspect_ah_where>`
	 */
    pointcut virtual where() = execution(acp::trace());


    Tracer(): Tracer(nullptr) {}

	/**
	 * \constructor Constructor
	 * \brief This constructor initializes the tracer with a builder, printer and thread controller.
	 */
    Tracer(acp::Printer* printer): _printer(printer) {
		Tracer::static_printer_instance(_printer);
	}

	virtual ~Tracer() {
		delete _printer;
	}

	/**
	 * \advice trace-advice
	 * \brief This advice is executed around the execution of functions or methods marked with the trace attribute.
	 *
	 * It measures the execution timestamp of the function or method.
	 * It uses heap instances of acp::TracerData to store the tracing data.
	 * The tracing data is updated in a thread-safe manner using the ThreadController.
	 *
	 * \see acp::TracerData
	 */
    advice where() && !ignore(): around() {
		acp::thread_controller::acquire_global_lock();
    	new acp::TracerData (JoinPoint::signature());
		acp::thread_controller::release_global_lock();
		tjp->proceed();
    }

	/**
	 * \function simple_stat
	 * \brief This function prints the tracing data of all traced functions and methods.
	 */
    static void simple_stat () {
        std::vector<std::string> outputs;
        for (acp::TracerData *curr = acp::TracerData::first(); curr; curr = curr->p_next) {
			std::string output;
			build_msg(*curr, output);
			outputs.push_back(output);
		}
		for(int i = outputs.size() - 1; i >= 0; --i) {
			Tracer::static_printer_instance()->print(outputs[i]);
        }
      }

	  /**
	   * \function summary
	   * \brief This function returns a pointer to the simple_stat function.
	   *
	   * This function is virtual and can therefore be overridden by derived classes.
	   * It is used to provide the register-advice with a function pointer to be called at exit.
	   * \return (In this case) A pointer to the simple_stat function, which prints the tracing data.
	   */
    virtual void (*summary())() {
        return &simple_stat;
      }

	/**
	 * \advice register-advice
	 * \brief This advice registers the summary function to at_exit to delay the printing as much as possible.
	 *
	 * Atexit will receive the result of the summary() function. it expects a function pointer to
	 * a function that returns void and takes no arguments and is not class bound. Using the atexit()
	 * function, the most amount of information can be gathered about the program before it exits.
	 */
    advice execution (acp::main_function()) : after () {
        atexit (summary());
    }

};

#endif // __ACP__TRACER_AH__
